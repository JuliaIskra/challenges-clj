(ns project-euler.core
  (:gen-class))

(defn problem1
  "https://projecteuler.net/problem=1
  If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
  The sum of these multiples is 23.
  Find the sum of all the multiples of 3 or 5 below 1000."
  []
  (->> (range 1000)
       (filter (fn [n] (or (zero? (mod n 3)) (zero? (mod n 5)))))
       (reduce +)))


(defn calc-fib
  [limit]
  (loop [fib-seq [1 2]]
    (let [next (reduce + (take-last 2 fib-seq))]
      (if (> next limit)
        fib-seq
        (recur (concat fib-seq [next]))))))

(defn problem2
  "https://projecteuler.net/problem=2
  Each new term in the Fibonacci sequence is generated by adding the previous two terms.
  By starting with 1 and 2, the first 10 terms will be:
  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
  By considering the terms in the Fibonacci sequence whose values do not exceed four million,
  find the sum of the even-valued terms."
  []
  (->> (calc-fib 4000000)
       (filter even?)
       (reduce +)))


(defn calc-min-prime-factor
  [n]
  (->> (range 2 n)
       (map (fn [div] [div (mod n div)]))
       (filter (fn [[div rem]] (zero? rem)))
       first
       first))

(defn problem3
  "https://projecteuler.net/problem=3
  The prime factors of 13195 are 5, 7, 13 and 29.
  What is the largest prime factor of the number 600851475143 ?"
  []
  (loop [n 600851475143]
    (let [min-factor (calc-min-prime-factor n)]
      (if (nil? min-factor)
        n
        (recur (/ n min-factor))))))


(defn palindrome?
  [n]
  (= (str n) (reduce str (reverse (str n)))))

(defn calc-palindrome-made-with-factor
  [n]
  (loop [f1 n
         f2 n]
    (let [product (* f1 f2)]
      (cond
        (= f2 99) nil
        (palindrome? product) product
        :else (recur f1 (dec f2))))))

(defn problem4
  "https://projecteuler.net/problem=4
  A palindromic number reads the same both ways.
  The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
  Find the largest palindrome made from the product of two 3-digit numbers."
  []
  (->> (range 999 99 -1)
       (map calc-palindrome-made-with-factor)
       (filter #(not (nil? %1)))
       (sort #(compare %2 %1))
       first))


(defn calc-prime-factors
  [num]
  (loop [n             num
         prime-factors []]
    (let [min-factor (calc-min-prime-factor n)]
      (if (nil? min-factor)
        (concat prime-factors [n])
        (recur (/ n min-factor) (concat prime-factors [min-factor]))))))

(defn exp
  [n exp]
  (reduce * (repeat exp n)))

(defn problem5
  "https://projecteuler.net/problem=5
  2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
  What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
  []
  (->> (range 1 21)
       (map calc-prime-factors)
       (map frequencies)
       (reduce #(merge-with max %1 %2) {})
       seq
       (reduce (fn [result [n mult]] (* result (exp n mult))) 1)))


(defn problem6
  "The sum of the squares of the first ten natural numbers is,
      1^2 + 2^2 + ... + 10^2 = 385
  The square of the sum of the first ten natural numbers is,
      (1 + 2 + ... + 10)^2 = 552 = 3025
  Hence the difference between the sum of the squares of the first ten natural numbers
  and the square of the sum is 3025 − 385 = 2640.
  Find the difference between the sum of the squares of the first one hundred natural numbers
  and the square of the sum."
  []
  (- (exp (reduce + (range 1 101)) 2)
     (reduce + (map #(exp %1 2) (range 1 101)))))


(defn problem7
  "By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
  What is the 10001st prime number?"
  []
  (loop [prime-numbers []
         count         0
         next          2]
    (if (== 10001 count)
      (last prime-numbers)
      (if (->> prime-numbers
               (map #(mod next %1))
               (filter zero?)
               empty?)
        (do (recur (concat prime-numbers [next])
                   (inc count)
                   (inc next)))
        (do (recur prime-numbers
                   count
                   (inc next)))))))


(defn -main
  [number & args]
  (println (str "Running solution for problem #" number))
  (println ((resolve (symbol (str "project-euler.core/problem" number))))))

